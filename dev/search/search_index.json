{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LuxCore.jl: Interface to Lux.jl","text":""},{"location":"#luxcore","title":"LuxCore","text":"<p><code>LuxCore.jl</code> defines the abstract layers for Lux. Allows users to be compatible with the entirely of <code>Lux.jl</code> without having such a heavy dependency. If you are depending on <code>Lux.jl</code> directly, you do not need to depend on <code>LuxCore.jl</code> (all the functionality is exported via <code>Lux.jl</code>).</p> <p></p> <p></p>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#index","title":"Index","text":"<ul> <li><code>LuxCore.AbstractExplicitContainerLayer</code></li> <li><code>LuxCore.AbstractExplicitLayer</code></li> <li><code>LuxCore.apply</code></li> <li><code>LuxCore.display_name</code></li> <li><code>LuxCore.initialparameters</code></li> <li><code>LuxCore.initialstates</code></li> <li><code>LuxCore.parameterlength</code></li> <li><code>LuxCore.setup</code></li> <li><code>LuxCore.statelength</code></li> <li><code>LuxCore.testmode</code></li> <li><code>LuxCore.trainmode</code></li> <li><code>LuxCore.update_state</code></li> </ul>"},{"location":"#abstract-types","title":"Abstract Types","text":"<p># <code>LuxCore.AbstractExplicitLayer</code> \u2014 Type.</p> <pre><code>AbstractExplicitLayer\n</code></pre> <p>Abstract Type for all Lux Layers</p> <p>Users implementing their custom layer, must implement</p> <ul> <li><code>initialparameters(rng::AbstractRNG, layer::CustomAbstractExplicitLayer)</code> \u2013 This returns a <code>NamedTuple</code> containing the trainable parameters for the layer.</li> <li><code>initialstates(rng::AbstractRNG, layer::CustomAbstractExplicitLayer)</code> \u2013 This returns a NamedTuple containing the current state for the layer. For most layers this is typically empty. Layers that would potentially contain this include <code>BatchNorm</code>, <code>LSTM</code>, <code>GRU</code> etc.</li> </ul> <p>Optionally:</p> <ul> <li><code>parameterlength(layer::CustomAbstractExplicitLayer)</code> \u2013 These can be automatically calculated, but it is recommended that the user defines these.</li> <li><code>statelength(layer::CustomAbstractExplicitLayer)</code> \u2013 These can be automatically calculated, but it is recommended that the user defines these.</li> </ul> <p>See also <code>AbstractExplicitContainerLayer</code></p> <p>source</p> <p># <code>LuxCore.AbstractExplicitContainerLayer</code> \u2014 Type.</p> <pre><code>AbstractExplicitContainerLayer{layers} &lt;: AbstractExplicitLayer\n</code></pre> <p>Abstract Container Type for certain Lux Layers. <code>layers</code> is a tuple containing fieldnames for the layer, and constructs the parameters and states using those.</p> <p>Users implementing their custom layer can extend the same functions as in <code>AbstractExplicitLayer</code>.</p> <p>Tip</p> <p>Advanced structure manipulation of these layers post construction is possible via <code>Functors.fmap</code>. For a more flexible interface, we recommend using the experimental feature <code>Lux.@layer_map</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"#general","title":"General","text":"<p># <code>LuxCore.apply</code> \u2014 Function.</p> <pre><code>apply(model::AbstractExplicitLayer, x, ps, st::NamedTuple)\n</code></pre> <p>Simply calls <code>model(x, ps, st)</code></p> <p>source</p> <p># <code>LuxCore.display_name</code> \u2014 Function.</p> <pre><code>display_name(layer::AbstractExplicitLayer)\n</code></pre> <p>Printed Name of the <code>layer</code>. If the <code>layer</code> has a field <code>name</code> that is used, else the type name is used.</p> <p>source</p> <p># <code>LuxCore.setup</code> \u2014 Function.</p> <pre><code>setup(rng::AbstractRNG, l::AbstractExplicitLayer)\n</code></pre> <p>Shorthand for getting the parameters and states of the layer <code>l</code>. Is equivalent to <code>(initialparameters(rng, l), initialstates(rng, l))</code>.</p> <p>Warning</p> <p>This function is not pure, it mutates <code>rng</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"#parameters","title":"Parameters","text":"<p># <code>LuxCore.initialparameters</code> \u2014 Function.</p> <pre><code>initialparameters(rng::AbstractRNG, l)\n</code></pre> <p>Generate the initial parameters of the layer <code>l</code>.</p> <p>source</p> <p># <code>LuxCore.parameterlength</code> \u2014 Function.</p> <pre><code>parameterlength(l)\n</code></pre> <p>Return the total number of parameters of the layer <code>l</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"#states","title":"States","text":"<p># <code>LuxCore.initialstates</code> \u2014 Function.</p> <pre><code>initialstates(rng::AbstractRNG, l)\n</code></pre> <p>Generate the initial states of the layer <code>l</code>.</p> <p>source</p> <p># <code>LuxCore.statelength</code> \u2014 Function.</p> <pre><code>statelength(l)\n</code></pre> <p>Return the total number of states of the layer <code>l</code>.</p> <p>source</p> <p># <code>LuxCore.testmode</code> \u2014 Function.</p> <pre><code>testmode(st::NamedTuple)\n</code></pre> <p>Make all occurances of <code>training</code> in state <code>st</code> \u2013 <code>Val(false)</code>.</p> <p>source</p> <p># <code>LuxCore.trainmode</code> \u2014 Function.</p> <pre><code>trainmode(st::NamedTuple)\n</code></pre> <p>Make all occurances of <code>training</code> in state <code>st</code> \u2013 <code>Val(true)</code>.</p> <p>source</p> <p># <code>LuxCore.update_state</code> \u2014 Function.</p> <pre><code>update_state(st::NamedTuple, key::Symbol, value; layer_check=_default_layer_check(key))\n</code></pre> <p>Recursively update all occurances of the <code>key</code> in the state <code>st</code> with the <code>value</code>.</p> <p>source</p>"}]}